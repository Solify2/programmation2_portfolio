{"/s%C3%A9ance_1/":{"data":{"1type-queue#1.Type Queue":"Une file d’attente, ou “queue” en anglais, est un type de donnée où les données sont récupérées selon un mécanisme “first in first out”.\n1.1.Concret ou abstrait? Jetez un œil sur le fichier queue.h reproduit ici. S’agit-il d’un type de donnée abstrait ou concret? Justifiez vos réponses en vous basant sur les définitions de ces types de données.\nNote\nEn analysant le fichier queue.h, nous pouvons déduire qu’il s’agit d’un type de donnée abstrait (ADT). Cela se base sur la définition d’un type abstrait, qui consiste à décrire le comportement et les propriétés d’un type sans préciser comment il est implémenté. Dans notre exemple de “queue”, qui est une ADT, nous définissons un type de donnée qui prend en charge l’ajout (empiler) et la suppression (dépiler) en utilisant le principe LIFO (Last In First Out). Cela se fait sans indiquer comment le programme va précisément fonctionner. En résumé, un ADT décrit ce que notre programme doit accomplir sans spécifier les détails de son fonctionnement en coulisses\nNote\nAvec mes connaissances préalables en programmation orientée objet, et plus précisément en Java, je dirais que cela m’a aidé à établir un lien avec les concepts d’une classe abstraite ou d’une méthode abstraite, qui servent uniquement à représenter un concept sans implémentation concrète.\n1.2.Utilisation de la Queue Sans connaître l’implémentation de la Queue, pouvez-vous prédire ce qui va être affiché lors de l’exécution du programme “manipulation_queue.c”? Si oui, indiquez ce qui va être affiché.\nEst-ce que plusieurs implémentations concrètes correctes de la Queue sont possibles? Cela va-t-il influencer l’expérience de l’utilisateur du programme “manipulation_queue.c”? Si oui, en quoi? Sinon, pourquoi?\nNote\nOui, plusieurs implémentations concrètes d’une queue sont possibles, par exemple en utilisant un tableau classique ou une liste chaînée (simple ou double) Cela pourrait effectivement influencer l’expérience de l’utilisateur, car chaque implémentation a ses propres avantages et inconvénients, et cela dépend de plusieurs facteurs Par exemple, si on implémente la queue avec un tableau et que celui-ci contient des milliers d’éléments, il faudra peut-être redimensionner le tableau en copiant ces éléments dans un nouveau tableau Cela entraînera un coût supplémentaire. De plus, avec un tableau, il y a une limitation si la taille est fixée, car à un moment donné, lorsqu’on tente d’ajouter un nouvel élément (enqueue), cela pourrait entraîner un message indiquant que la queue est remplie\n1.3. Définition d’une Queue Identifiez les éléments clés qui permettent de définir une Queue (en particulier : les opérations et propriétés d’une Queue).","2implémentation-de-la-queue#2.Implémentation de la Queue":"Vous allez implémenter une Queue à partir du fichier d’entête qui a été donné. Suivez les étapes!\n2.1. Coffre-fort Examinez le code “coffre_fort.c” qui vous est fourni et utilisez-le pour clarifier les éléments suivants :\n-Comment est définie concrètement une structure en C? En particulier, comment la nommer, comment créer un type synonyme (ou alias), comment définir des champs?\n-Comment créer, en C, un tableau dont on ne connaît pas la taille avant l’exécution du programme?\n-À quoi sert “malloc”? Comment l’employer? Que prend-il comme argument? Que renvoie-t-il?\n-À quoi sert “free”? Pourquoi l’employer? Que prend-il en argument?\n2.2.Listes simplement chainées La liste simplement chainée est un type de donné concret dynamique (dont la taille n’est pas fixée à l’avance).\nDéterminez ce qu’est concrètement une liste simplement chainée et proposez-en une implémentation en C.\nSuggestion : définissez deux structures. Une pour la liste “en elle-même” et une pour les nœuds de la liste, qui s’enchainent dont le dernier pointe vers NULL.\nProposez ensuite une implémentation d’une liste doublement chainée et d’une liste doublement chainée circulaire.\n2.3. Tests de la Queue Écrivez une fonction qui vous permettra de tester la Queue que vous allez implémenter à l’étape suivante. Dans cette fonction, vous veillerez à tester chacune des 5 fonctions définie dans le fichier d’entête. N’hésitez pas à vous répartir le travail, pour que chacun et chacune se concentre sur une ou deux fonction et prévoie de la tester à fond. Veillez à ce que cette fonction indique à chaque fois quelque chose du type:\nTest de la fonction f\nTest 1 : réussi\nTest 2 : réussi\nTest 3 : échoué\n…\nTest de la fonction f\nTest 1 : réussi\nTest 2 : échoué\n…\n2.4.Implémentation de la Queue Proposez deux manières d’implémenter la Queue, au moyen d’une structure statique (par exemple, un tableau) et au moyen d’une structure dynamique (par exemple, une liste chainée simple, doublement chainée, chainée circulaire, etc.).\nDéterminez les avantages et inconvénients de chacune de ces deux implémentations.","3la-pile-stack#3.La pile (Stack)":"3.1.C’est quoi une pile? Stack est un ADT. Déterminez les opérations et propriétés qui permettent de le définir.\n3.2.Fichier d’entête À partir de la définition que vous avez donnée d’une pile, déterminez un fichier d’entête (.h) qui contient la signature des fonctions qui permettent de définir cet ADT. Pour chacune de ces fonctions, indiquez bien ses préconditions et postconditions.\n3.3.Implémentation d’une pile Implémentez la pile définie précédemment dans un fichier .c de deux façons différentes : au moyen de tableaux et au moyen de listes chainées (simplement, ou doublement, ou circulaire).","4des-exercices-supplémentaires#4.Des exercices supplémentaires":"Sur Webcampus, vous trouverez 4 exercices supplémentaires à réaliser qui vous permettront de travailler les différents concepts vus lors de cette séance :\n-Un exercice de compression de données, pour manipuler des tableaux et des files\n-Un exercice de chiffrement de données, pour manipuler des files\n-Un exercice de calculatrice, pour manipuler des piles\n-Un exercice de bataille, pour manipuler des piles","dattente--queue-#d’attente ( Queue )":"Les objectifs de cette séance, et du travail individuel à fournir d’ici la séance suivante, sont :\n1-Se remettre à flot avec les concepts de base du C vus au précédent quadrimestre : types, variables, expressions arithmétiques, conditions, boucles, chaines de caractères, fonctions, structures, pointeurs\n2-Comprendre et savoir utiliser l’ allocation dynamique de mémoire en C (malloc) et la libération de la mémoire allouée (free)\n3-Comprendre la différence entre les fichiers .c et les fichier d’entête .h et être capables, lors de l’écriture d’un programme, de jongler entre les deux\n4- Compiler des projets composés de plusieurs fichiers .c et .h\n5-Comprendre le principe d’un type abstrait de données (abstract data type, ADT)\n6-Être capable d’ implémenter concrètement un ADT donné, de plusieurs manières\n7-Utiliser les ADT \" file d’attente \" et \" pile \" pour résoudre des problèmes concrets en C","séance-1--autour-dune-file#Séance 1 : autour d’une file":"Séance 1 : autour d’une file"},"title":"Séance_1"},"/s%C3%A9ance_1/4_exercsies/1.compression/":{"data":{"":" // // Created by Ahmed Soleiman on 06/03/2025. // #include \u003cstdio.h\u003e int compresser(int message[], int tailleMessage){ int current = message[0]; int i = 1; int j = 0; int nb_seq_val = 1; int result[50]; while(tailleMessage \u003e 1){ if(message[i]==current){ nb_seq_val++; i++; tailleMessage--; }else{ result[j] = current; j = j + 1; result[j] = nb_seq_val; nb_seq_val = 0; current = message[i]; j+=1; } } result[j] = current; j = j + 1; result[j] = nb_seq_val; for(int k=0;k\u003c=j;k++){ printf(\"%d \",result[k]); } } int main() { int arr[17] = {1,1,2,2,2,3,4,4,5,5,10,10,10,7,7,7,7}; compresser(arr,17); return 0; } "},"title":"1.compression"},"/s%C3%A9ance_1/list/list/":{"data":{"#":"Implémentation d’une liste chainéeest une structure permettant d’implémenter une liste, c’est-à-dire une séquence finie de valeurs (de même type ou non). Les éléments sont dits chainés car à chaque élément est associé l’adresse mémoire de l’élément suivant de la liste.\nOn a représente ici une liste chainée de trois éléments :\nflowchart LR id1[[10]] --\u003e id2[[13]] --\u003e id3[[20]] Le premier est 10 et il pointe vers l’adresse mémoire du second ; deuxième élément est 13 et il pointe vers l’adresse mémoire du troisième ; Le troisième élément est 20 et Il ne pointe vers rien (l’adresse du suivant est NULL). nous avons donc atteint la fin de la liste. Les différentes functions suivantes ont été implémentées pour manipuler la liste (Voir header file):\ninsert_value_at_start insert_value_at_end insert_after delete_node destory_list display_list #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cstdbool.h\u003e #include \"list.h\" #define MAX_SIZE 100 typedef struct Node { int value; struct Node *next; } Node; typedef struct List { Node *head; Node *tail; int size; } List; List_t new_list() { List_t list = malloc(sizeof(List)); list-\u003ehead = NULL; list-\u003etail = NULL; list-\u003esize = 0; return list; } Node_t create_node(int element) { Node_t new_node = malloc(sizeof(Node)); new_node-\u003evalue = element; new_node-\u003enext = NULL; return new_node; } void insert_value_at_start(List_t list, int value) { Node_t new_node = create_node(value); if (list == NULL) { printf(\"Liste invalide (null)\\n\"); return; } if (list-\u003ehead == NULL) { list-\u003ehead = new_node; list-\u003etail = new_node; }else { new_node-\u003enext = list-\u003ehead; list-\u003ehead = new_node; } list-\u003esize++; } void insert_value_at_end(List_t list, int value) { Node_t new_node = create_node(value); if (list-\u003etail == NULL) { list-\u003ehead = new_node; list-\u003etail = new_node; }else { list-\u003etail-\u003enext = new_node; list-\u003etail = new_node; } list-\u003esize++; } void insert_after(List_t list, Node_t prev_node, int value) { if (list == NULL) { printf(\"Liste invalide (null)\\n\"); } if (prev_node == NULL) { printf(\"Error in insert_after\\n\"); return; } Node_t new_node = create_node(value); new_node-\u003enext = prev_node-\u003enext; prev_node-\u003enext = new_node; if (prev_node == list-\u003etail) { list-\u003etail = new_node; } list-\u003esize++; } Node_t find_node(List_t list, int value) { Node_t current_value = list-\u003ehead; while (current_value != NULL) { if (current_value-\u003evalue == value) { return current_value; } current_value = current_value-\u003enext; } return NULL; } void display_list(List_t list) { Node_t current = list-\u003ehead; printf(\"size %d \\n\", list-\u003esize); while (current != NULL) { printf(\"%d -\u003e \", current-\u003evalue); current = current-\u003enext; } } void destroy_list(List_t list) { Node_t current_node = list-\u003ehead; Node_t next_node = NULL; while (current_node != NULL) { next_node = current_node-\u003enext; free(current_node); current_node = next_node; } free(list); } int main(){ printf(\"Insérer dans une liste invalide (NULL)\\n\"); insert_value_at_start(NULL,100); printf(\"---------------\\n\"); printf(\"Initialisé une liste\\n\"); List_t list = new_list(); printf(\"Insértion at end : 3 \\n\"); insert_value_at_end(list, 3); display_list(list); printf(\"\\n---------------\\n\"); printf(\"Insértion at end : 4 \\n\"); insert_value_at_end(list, 4); display_list(list); printf(\"\\n---------------\\n\"); printf(\"Insértion at end : 6 \\n\"); insert_value_at_end(list, 6); display_list(list); printf(\"\\n---------------\\n\"); printf(\"Insértion at start : 2 \\n\"); insert_value_at_start(list, 2); display_list(list); printf(\"\\n---------------\\n\"); printf(\"Insértion at start : 1 \\n\"); insert_value_at_start(list, 1); display_list(list); printf(\"\\n---------------\\n\"); display_list(list); printf(\"\\n---------------\\n\"); Node_t temp = find_node(list, 4); if (temp != NULL) { printf(\"Insértion 20 after: 4 \\n\"); insert_after(list, temp, 20); } display_list(list); printf(\"\\n---------------\\n\"); printf(\"\\nDestroy list -\u003e OK\\n\"); destroy_list(list); return 0; } Voici un exemple d’exécution de la liste chainée : Insérer dans une liste invalide (NULL) Liste invalide (null) --------------- Initialisé une liste Insértion at end : 3 size 1 3 -\u003e --------------- Insértion at end : 4 size 2 3 -\u003e 4 -\u003e --------------- Insértion at end : 6 size 3 3 -\u003e 4 -\u003e 6 -\u003e --------------- Insértion at start : 2 size 4 2 -\u003e 3 -\u003e 4 -\u003e 6 -\u003e --------------- Insértion at start : 1 size 5 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 6 -\u003e --------------- Insértion 20 after: 4 size 6 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 20 -\u003e 6 -\u003e --------------- Destroy list -\u003e OK Process finished with exit code 0 ","implémentation-dune-liste-chainée#Implémentation d’une liste chainée":""},"title":"list"},"/s%C3%A9ance_1/list/list_header/":{"data":{"définition-des-fonctions-de-la-liste-chainée#Définition des fonctions de la liste chainée":" #ifndef LIST_H #define LIST_H struct List; struct Node; typedef struct List* List_t; typedef struct Node* Node_t; List_t new_list(); Node_t create_node(int value); void insert_value_at_start(List_t list, int value); void insert_value_at_end(List_t list, int value); void insert_after(List_t list, Node_t node, int value); void delete_node(Node_t node, int value); void destory_list(List_t list); void display_list(List_t list); Node_t find_node(List_t list, int value); #endif ","fichier-den-tête#Fichier d\u0026rsquo;en-tête":"Fichier d’en-tête"},"title":"list_header"},"/s%C3%A9ance_1/questions/":{"data":{"":"","exercice-11--de-la-séance-1#Exercice 1.1  de la séance 1,":"Exercice 1.1 de la séance 1, 1.1.Concret ou abstrait ? Jetez un œil sur le fichier queue.h reproduit ici. S’agit-il d’un type de donnée abstrait ou concret ? Justifiez vos réponses en vous basant sur les définitions de ces types de données.\nEn analysant le fichier queue.h, nous pouvons déduire qu’il s’agit d’un type de donnée abstrait (ADT). Cela se base sur la définition d’un type abstrait, qui consiste à décrire le comportement et les propriétés d’un type sans préciser comment il est implémenté. Dans notre exemple de “queue”, qui est une ADT, nous définissons un type de donnée qui prend en charge l’ajout (empiler) et la suppression (dépiler) en utilisant le principe LIFO (Last In First Out). Cela se fait sans indiquer comment le programme va précisément fonctionner. En résumé, un ADT décrit ce que notre programme doit accomplir sans spécifier les détails de son fonctionnement en coulisses","exercice-12--de-la-séance-1#Exercice 1.2  de la séance 1":"1.2.Utilisation de la Queue Est-ce que plusieurs implémentations concrètes correctes de la Queue sont possibles ? Cela va-t-il influencer l’expérience de l’utilisateur du programme “manipulation_queue.c” ? Si oui, en quoi ? Sinon, pourquoi ?\nRésolution: Oui, plusieurs implémentations concrètes d’une queue sont possibles, par exemple en utilisant un tableau classique ou une liste chaînée (simple ou double)\nCela pourrait effectivement influencer l’expérience de l’utilisateur, car chaque implémentation a ses propres avantages et inconvénients, et cela dépend de plusieurs facteurs Par exemple, si on implémente la queue avec un tableau et que celui-ci contient des milliers d’éléments, il faudra peut-être redimensionner le tableau en copiant ces éléments dans un nouveau tableau Cela entraînera un coût supplémentaire. De plus, avec un tableau, il y a une limitation si la taille est fixée, car à un moment donné, lorsqu’on tente d’ajouter un nouvel élément (enqueue), cela pourrait entraîner un message indiquant que la queue est remplie"},"title":"Questions"},"/s%C3%A9ance_1/queue/queue_header/":{"data":{"définition-des-fonctions-de-la-file-dattente#Définition des fonctions de la file d\u0026rsquo;attente":"Fichier d’en-têteDéfinition des fonctions de la file d’attente #ifndef QUEUE_H #define QUEUE_H #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e //Invariant de structure: pour toute Queue initialisée, size(q)\u003e=0 struct Queue; //déclaration du nom de ma structure typedef struct Queue* Queue_t; //déclaration d'un alias qui désigne le type \"pointeur vers struct Queue\" //PRE: / //POST: initialise une Queue vide et renvoie un pointeur vers celle-ci Queue_t new_queue(); //PRE: q est initialisé //POST: renvoie le nombre d'éléments présents dans q. q n'est pas modifiée. int size(Queue_t queue); //PRE: q est initialisé //POST: size(q') = size(q)+1 et le dernier élément de q est i. Le reste n'a pas été modifié void enqueue(Queue_t queue, int i); //PRE: q est initialisé, size(q)\u003e0 //POST: renvoie le premier élément de q (élément le plus anciennement mis dans q) et l'enlève de q. // size(q')=size(q)-1 // Le reste n'est pas modifié. int dequeue(Queue_t queue); //PRE: q est initialisée //POST: toute la mémoire allouée pour q est libérée void destroy_queue(Queue_t queue); #endif ","fichier-den-tête#Fichier d\u0026rsquo;en-tête":""},"title":"queue_header"},"/s%C3%A9ance_1/queue/queue_list/":{"data":{"#":"Implémentation d’une file d’attente (Queue) basée sur une liste chaînéeDans l’implémentation ci-dessous, la queue est implémentée en utilisant une liste chaînée. La queue est représentée par deux structures : struct Node et struct Queue.\nStruct Node : Représente un élément d’une liste contenant deux valeurs :\nLa valeur de l’élément de la liste quel que soit son type (int, char, double, array, etc…). Un pointeur vers l’élément suivant de la liste, ayant le même type que la structure elle-meme (struct Node*) et cela qui va permettre de créer un système de chaînage. Struct Queue : Représente la queue dans sa totalité (un ensemble de noeuds) et contient les éléments suivants :\nHead : La tête de la liste, représentant le premier élément. Tail : Le dernier élément de la liste. Size : La longueur de la liste chaînée. Avantages Inconvénients Allocation dynamique de la mémoire Moins facile à implémenter par rapport à l’implémentation avec un tableau L’insertion et la suppression sont efficaces et ne nécessitent pas de décalage Nécessite de parcourir toute la liste pour trouver un élément situé à la fin Certaines opérations peuvent être réalisées en temps constant (enqueue, dequeue) Gestion manuelle de la mémoire (malloc, free) #include \u003cstdlib.h\u003e #include \"../list/list.h\" #include \"queue.h\" #define MAX_SIZE 100 typedef struct Node { int value; struct Node *next; } Node; typedef struct Queue { Node *head; Node *tail; int size; } Queue; Queue_t new_queue() { Queue_t queue = malloc(sizeof(Queue)); queue-\u003ehead = NULL; queue-\u003etail = NULL; queue-\u003esize = 0; return queue; } int size(Queue_t queue) { if (queue == NULL || queue-\u003esize == 0) { return 0; } return queue-\u003esize; } void enqueue(Queue_t queue, int element) { Node_t new_node = malloc(sizeof(Node)); new_node-\u003evalue = element; if (queue == NULL) { printf(\"Queue invalide\\n\"); return; } if(queue-\u003esize==0) { queue-\u003ehead = new_node; queue-\u003etail = new_node; }else { queue-\u003etail-\u003enext = new_node; queue-\u003etail = new_node; } queue-\u003esize++; } int dequeue(Queue_t queue) { if(queue == NULL || queue-\u003esize==0) { printf(\"Queue invalide (vide/null)\\n\"); return 0; } int element = queue-\u003ehead-\u003evalue; Node_t old_head = queue-\u003ehead; if (queue-\u003esize==1) { queue-\u003ehead = NULL; queue-\u003etail = NULL; }else { queue-\u003ehead = queue-\u003ehead-\u003enext; } free(old_head); queue-\u003esize--; return element; } int main(){ Queue_t q = new_queue(); printf(\"Taille:%d\\n\",size(q)); enqueue(q,3); printf(\"Enqueue 3 \\n\"); printf(\"3 -\u003e NULL\\n\"); printf(\"Taille:%d\\n\",size(q)); printf(\"-------------\\n\"); enqueue(q,5); printf(\"Enqueue 5 \\n\"); printf(\"3 -\u003e 5 -\u003e NULL\\n\"); printf(\"Taille:%d\\n\",size(q)); printf(\"-------------\\n\"); enqueue(q,1); printf(\"Enqueue 1 \\n\"); printf(\"3 -\u003e 5 -\u003e 1 -\u003e NULL\\n\"); printf(\"Taille:%d\\n\",size(q)); printf(\"-------------\\n\"); int a = dequeue(q); printf(\"Dequeue \\n\"); printf(\"Élement enlevé:%d\\n\",a); printf(\"5 -\u003e 1 -\u003e NULL\\n\"); printf(\"-------------\\n\"); int b = dequeue(q); printf(\"Dequeue \\n\"); printf(\"Élement enlevé:%d\\n\",b); printf(\"1 -\u003e NULL\\n\"); printf(\"-------------\\n\"); printf(\"Taille:%d\\n\",size(q)); printf(\"Enqueue 6 \\n\"); enqueue(q,6); printf(\"1 -\u003e 6 -\u003e NULL\\n\"); printf(\"-------------\\n\"); int c = dequeue(q); printf(\"Dequeue \\n\"); printf(\"Élement enlevé:%d\\n\",c); printf(\"6 -\u003e NULL\\n\"); printf(\"-------------\\n\"); int d = dequeue(q); printf(\"Élement enlevé:%d\\n\",d); printf(\"Taille:%d\\n\",size(q)); printf(\"-------------\\n\"); printf(\"Queue vide...\\n\"); printf(\"Dequeue depuis une queue vide:\\n\"); dequeue(q); printf(\"Taille:%d\\n\",size(q)); free(q); return 0; } Voici un exemple d’exécution d’une file d’attente (Queue) basée sur une liste chainée Taille:0 Enqueue 3 3 -\u003e NULL Taille:1 ------------- Enqueue 5 3 -\u003e 5 -\u003e NULL Taille:2 ------------- Enqueue 1 3 -\u003e 5 -\u003e 1 -\u003e NULL Taille:3 ------------- Dequeue Élement enlevé:3 5 -\u003e 1 -\u003e NULL ------------- Dequeue Élement enlevé:5 1 -\u003e NULL ------------- Taille:1 Enqueue 6 1 -\u003e 6 -\u003e NULL ------------- Dequeue Élement enlevé:1 6 -\u003e NULL ------------- Élement enlevé:6 Taille:0 ------------- Queue vide... Dequeue depuis une queue vide: Queue invalide (vide/null) Taille:0 ","implémentation-dune-file-dattente-queue-basée-sur-une-liste-chaînée#Implémentation d’une file d’attente (Queue) basée sur une liste chaînée":""},"title":"queue_list"},"/s%C3%A9ance_1/queue/queue_tableau/":{"data":{"#":"Implémentation d’une file d’attente (Queue) basée sur un tableau (array)Dans l’implémentation ci-dessous, la queue est implémentée en utilisant un tableau de taille fixe (#define MAX_SIZE 100). La queue est représentée par une structure contenant deux éléments :\nUn tableau qui représente l’ensemble des éléments dans la file (des entiers dans cet exemple). Un entier (tail), permettant de garder une trace du dernier élément inséré dans la file. Avantages Inconvénients Facile à implémenter Capacité de stockage limitée Ne demande pas de connaissances sur d’autres structures (ex: liste chaînée) Allocation mémoire statique Certaines opérations peuvent être réalisées en temps constant (enqueue) Temps linéaire dû au décalage de tous les éléments restants Inconvinent:\n#include \u003cstdlib.h\u003e #include \"queue.h\" #define MAX_SIZE 100 struct Queue { int elements[MAX_SIZE]; int tail; }; Queue_t new_queue() { Queue_t queue = malloc(sizeof(struct Queue)); queue-\u003etail = -1; return queue; } int size(Queue_t queue) { if (queue == NULL || queue-\u003etail == -1) { return 0; } return (queue-\u003etail +1); } void enqueue(Queue_t queue, int element) { if (queue == NULL) { printf(\"Queue invalide\\n\"); return; } if (queue-\u003etail == MAX_SIZE - 1) { printf(\"Queue Rempli!\\n\"); } queue-\u003etail++; queue-\u003eelements[queue-\u003etail] = element; } int dequeue(Queue_t queue) { if (queue == NULL || size(queue) ==0) { printf(\"Queue invalide (vide/null)\\n\"); return 0; } int item = queue-\u003eelements[0]; for (int i = 0; i \u003c queue-\u003etail ; i++) { queue-\u003eelements[i] = queue-\u003eelements[i + 1]; } queue-\u003etail--; return item; } int main(){ printf(\"Enqueue dans une queue NULL \\n\"); enqueue(NULL,1); printf(\"-------------------\\n\"); printf(\"Initialisé une queue \\n\"); Queue_t queue = new_queue(); printf(\"Taille:%i\\n\",size(queue)); enqueue(queue,3); printf(\"Enqueue : 3 -\u003e size: %d \\n\", size(queue)); enqueue(queue,5); printf(\"Enqueue : 5 -\u003e size: %d \\n\", size(queue)); enqueue(queue,2); printf(\"Enqueue : 2 -\u003e size: %d \\n\", size(queue)); printf(\"-------------------\\n\"); int a = dequeue(queue); printf(\"dequeue : %d -\u003e size: %d \\n\", a,size(queue)); int b = dequeue(queue); printf(\"dequeue : %d -\u003e size: %d \\n\", b,size(queue)); int c = dequeue(queue); printf(\"dequeue : %d -\u003e size: %d \\n\", c,size(queue)); printf(\"-------------------\\n\"); enqueue(queue,1); printf(\"Enqueue : 1 -\u003e size: %d \\n\", size(queue)); int d = dequeue(queue); printf(\"dequeue : %d -\u003e size: %d \\n\", d,size(queue)); printf(\"-------------------\\n\"); printf(\"Dequeue depuis une queue vide:\\n\"); dequeue(queue); free(queue); return 0; } Voici un exemple d’exécution d’une file d’attente (Queue) basée sur un tableau (array) Enqueue dans une queue NULL Queue invalide ------------------- Initialisé une queue Taille:0 Enqueue : 3 -\u003e size: 1 Enqueue : 5 -\u003e size: 2 Enqueue : 2 -\u003e size: 3 ------------------- dequeue : 3 -\u003e size: 2 dequeue : 5 -\u003e size: 1 dequeue : 2 -\u003e size: 0 ------------------- Enqueue : 1 -\u003e size: 1 dequeue : 1 -\u003e size: 0 ------------------- Dequeue depuis une queue vide: Queue invalide (vide/null) Process finished with exit code 0 ","implémentation-dune-file-dattente-queue-basée-sur-un-tableau-array#Implémentation d’une file d’attente (Queue) basée sur un tableau (array)":""},"title":"queue_tableau"},"/s%C3%A9ance_1/stack/stack_header/":{"data":{"":" #ifndef STACK_H #define STACK_H struct Stack; typedef struct Stack* Stack_t; Stack_t new_stack(); void push(Stack_t stack, int value); int pop(Stack_t stack); int size(Stack_t stack); void destroy_stack(Stack_t stack); void display_stack(Stack_t stack); #endif //STACK_H "},"title":"stack_header"},"/s%C3%A9ance_1/stack/stack_list/":{"data":{"":"","#":" // // Created by Ahmed Soleiman on 03/03/2025. // #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \"../list/list.h\" #include \"../stack/stack.h\" typedef struct Node { int value; struct Node *next; } Node; typedef struct Stack { Node *head; int size; } Stack; Node_t create_node(int data) { Node_t new_node = malloc(sizeof(Node)); new_node-\u003evalue = data; new_node-\u003enext = NULL; return new_node; } Stack_t new_stack() { Stack_t stack = malloc(sizeof(Stack)); stack-\u003ehead = NULL; stack-\u003esize = 0; return stack; } void push(Stack_t stack, int value) { Node_t new_node = create_node(value); if (stack-\u003ehead == NULL) { stack-\u003ehead = new_node; }else { new_node-\u003enext = stack-\u003ehead; stack-\u003ehead = new_node; } stack-\u003esize++; } int pop(Stack_t stack) { if(stack-\u003esize==0) { return -1; } int value = stack-\u003ehead-\u003evalue; Node_t old_head = stack-\u003ehead; if (stack-\u003esize==1) { stack-\u003ehead = NULL; }else { stack-\u003ehead = stack-\u003ehead-\u003enext; } free(old_head); stack-\u003esize--; return value; } int size(Stack_t stack) { return stack-\u003esize; } int main(int argc, char **argv) { printf(\"Hello World!\\n\"); Stack_t stack = new_stack(); push(stack,3); printf(\"Push 3 \\n\"); printf(\"3 -\u003e NULL\\n\"); printf(\"Taille:%i\\n\",size(stack)); printf(\"-------------\\n\"); push(stack,5); printf(\"Push 5 \\n\"); printf(\"5 -\u003e 3 -\u003e NULL\\n\"); printf(\"Taille:%i\\n\",size(stack)); printf(\"-------------\\n\"); push(stack,1); printf(\"Push 1 \\n\"); printf(\"1 -\u003e 5 -\u003e 3 -\u003e NULL\\n\"); printf(\"Taille:%i\\n\",size(stack)); printf(\"-------------\\n\"); int a = pop(stack); printf(\"Pop \\n\"); printf(\"Élement enlevé:%i\\n\",a); printf(\"5 -\u003e 3 -\u003e NULL\\n\"); printf(\"-------------\\n\"); int b = pop(stack); printf(\"Pop \\n\"); printf(\"Élement enlevé:%i\\n\",b); printf(\"3 -\u003e NULL\\n\"); printf(\"-------------\\n\"); int c = pop(stack); printf(\"Pop \\n\"); printf(\"Élement enlevé:%i\\n\",c); } Voici un exemple d’exécution d’une stack basée sur une liste chainée Push élément dans une stack NULL: Stack invalide (NULL) ------------- Init Stack... ------------- Push 3 size 1 3 -\u003e ------------- Push 5 size 2 5 -\u003e 3 -\u003e ------------- Push 1 size 3 1 -\u003e 5 -\u003e 3 -\u003e ------------- Pop Élement enlevé:1 size 2 5 -\u003e 3 -\u003e ------------- Pop Élement enlevé:5 size 1 3 -\u003e ------------- Pop Élement enlevé:3 size 0 ------------- Pop depuis une stack vide... Stack invalide (vide/null) ------------- Pop depuis une référence NULL... Stack invalide (vide/null) ------------- Process finished with exit code 0 "},"title":"stack_list"},"/s%C3%A9ance_2/":{"data":{"":"Pages can be organized into folders.s"},"title":"Séance_2"},"/s%C3%A9ance_3/":{"data":{"":"Pages can be organized into folders. s"},"title":"Séance_3"},"/s%C3%A9ance_4/":{"data":{"":"Pages can be organized into folders."},"title":"Séance_4"}}